\documentclass{report}

\usepackage{listings}
\usepackage[vlined, boxed]{algorithm2e}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{float}
%\usepackage{geometry}
\usepackage{mathtools}
\usepackage{titlesec}


\titleformat{\chapter}[hang]
  {\normalfont\huge\bfseries}   % formatting for chapter title (font size, style)
  {\thechapter.}                % the label (chapter number followed by a period)
  {1em}                         
  {}
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

\SetAlCapSkip{2mm}

\bibliographystyle{apalike}

\title{Implementation and Evaluation of the FunArray\\[1em]\large{}Bachelor's Thesis\\[1em]Software and Computational Systems Lab\\Ludwig-Maximilians-Universit\"at M\"unchen}
\date{September 2024}
\author{Maximilian Hofstetter}
%\institute{Software and Computational Systems Lab\\Ludwig-Maximilians-Universit\"at M\"unchen}
%\subtitle{Bachelor's Thesis}

\newcommand{\funArray}[1]{$#1$}
\newcommand{\bound}[1]{\{#1\}}
\newcommand{\fvalue}[1]{\;#1\;}



\begin{document}

\maketitle

\chapter{Introduction}
\chapter{Background}
\chapter{Implementation}
\chapter{Evaluation}

\section{Expected Limitations}
\subsection{Adjacent potentially empty segments}
When expanding a segment by inserting a value adjacent to it, formerly adjacent and potentially empty segments will be joined with their nearest neighbour until a non-empty segment is reached. Let us consider the FunArray \funArray{A:\bound{a} \fvalue{x} \bound{b} \fvalue{y} \bound{c}? \fvalue{z} \bound{d}} for example. It is unknown whether its second segment containing the value $y$ is empty or not and thus whether $b=c$ or $b<c$ is true.

When trying to expand the first segment by inserting its value $x$ at index $b$, the resulting FunArray could either be \funArray{\bound{a} \fvalue{x} \bound{b\;c} \fvalue{x} \bound{b+1}? \fvalue{z} \bound{d}}, if the $y$-segment was empty, or alternatively \funArray{\bound{a} \fvalue{x} \bound{b} \fvalue{x} \bound{b+1} \fvalue{y} \bound{c}? \fvalue{z} \bound{d}}, if it was non-empty. Since the position of the \funArray{\bound{c}}-bound cannot by decided, it must be discarded altogether. After the insertion, $A$ becomes \funArray{A':\bound{a} \fvalue{x} \bound{b} \fvalue{x} \bound{b+1}? \fvalue{y\sqcup z} \bound{d}} and all information concerning the variable $c$ is lost.

 Analyses of programs utilising segments in their arrays with adjacent and potentially empty segments have to discard non-trivial information. Thus the FunArray's approach for handling potentially empty adjacent segments limits the number of programs for which an analysis can achieve a non-trivial result.
 
 Consider Algorithm \ref{algo:dijkstra}, Dijkstra's Dutch national flag algorithm, for example. Even though the analysis correctly determines the Array to be described as $\bound{0} \fvalue{[-\infty, -1]} \bound{r}? \fvalue{\top} \bound{w}? \fvalue{[0, 0]} \bound{b}? \fvalue{[1, \infty]}  \bound{|A|}?$ after a single loop pass, it loses all its information in the second pass, because the determined segments are all potentially empty and extending their neighbours discards them altogether. After the second loop pass the analysis yields $\bound{0} \fvalue{\top} \bound{|A|}$. Basically no information can be gained   
 
\input{res/dijkstra_algorithm.tex}
\section{Experimental evaluation}

Cousot, Cousot and Logozzo evaluate their implementation of the FunArray by analysing the main libraries of the .NET framework and the implementation itself \cite{cousot2011}. The .NET libraries have been chosen for this since they contain a large amount of code and a vast selection of functionalities and techniques. They, however, lack an important aspect: The specification of expected properties. The authors are able to infer thousands of invariants but cannot determine whether they actually provide any useful information for the further execution of the code. To check against pre-specified properties they ran the analysis on the implementation of the FunArray itself and annotated it with pre-conditions and proof obligations. 

%todo: Ist in der Ich-Perspektive schreiben okay? 

I tested my implementation of the FunArray against a selection of the SV\nobreakdash-COMP benchmarks\footnote{A collection of verification tasks for the International Competition on Software Verification available at \url{https://gitlab.com/sosy-lab/benchmarking/sv-benchmarks}}. These benchmarks each contain one or more assertions and their expected verdict. The 237 selected benchmarks are tailored towards verifying programs dealing with arrays.

\subsection{Technical aspects}

The selected benchmarks have been chosen \textcolor{red}{@Gidon By what criterion have they been chosen?}. The benchmarks are available as programs written in C and have been translated into the appropriate embedded domain-specific language in Java. Since my implementation of the FunArray only supports a limited amount of C commands, not all selected benchmarks were able to be properly translated and have been omitted instead.

The benchmarks have been executed with the interval abstract domain as its representation of variable values and array element values. This domain has been chosen because it is relatively simple to implement but can represent a value somewhat accurately.

The execution time of the benchmarks is almost negligible. To execute all 237 benchmarks it takes 253 milliseconds (Averaged value over 100 runs. The workbench used is a M2 Max MacBook Pro running OpenJDK 22). This comes down to about a millisecond per benchmark. This result was expected, since the FunArray does not handle disjunctions separately but through the use of empty segments. No combinatorial explosion can occur.

\subsection{Verifying assertions}

My implementation is able to correctly identify the result of 24 out of the 247 assertions spread among 237 benchmarks. When manually inspecting the program mechanism preceding these assertions in the benchmark, a single pattern can be identified that precedes the majority of them: Initialisation. The benchmark first initialises an array with a consistent value as its every element and immediately afterwards asserts that every element of the array has that specific value. Of the 24 correctly assessed assertions, 20 follow this pattern. The remaining four assertions follow a more complex program scheme, that involves conditions and loops.
Cousot, Cousot and Logozzo were able to correctly assert 61 out of 1800 or 3.4\% of proof obligations when analysing the FunArray implementation using itself \cite{cousot2011}. This roughly matches my results of 24 out of 247 or 9.7\%, considering the easy initialisation assertions make up a way greater amount of my test cases than would be present in a real world program.

\subsection{Invariants}
Another method of evaluating the impact of the FunArray, that was also chosen by its inventors \cite{cousot2011}, is the analysis of loop invariants. Spread across the 238 benchmarks there are 947 loops. For 580 or 61.3\% of those my implementation of the FunArray was able to determine a non-trivial invariant. A non-trivial invariant is defined as a state in which at least one of the arrays contains a segment whose value is not $\top$.
This definition of non-triviality, however, does not take the FunArrays ability to depict multiple segments into account. If we were to treat all arrays as a single segment with a homogenous value across all elements, we could have gotten the same result and the same number of non-trivial invariants. We therefore narrow down the non-triviality criterion to those states containing at least one array with more than one segment and at least one segment with a value that is not $\top$. Now we arrive at 427 non-trivial invariants, which is still 45.0\%. 
If we were to increase the required number of segments to more than two, this number would drop down to 3, suggesting the FunArrays ability to depict a lot of segments cannot be utilised in actual code analyses. No calculated invariants had more than three segments.


\chapter{Conclusion}



\newpage
\bibliographystyle{plain}
\bibliography{Bibliography}
\end{document}