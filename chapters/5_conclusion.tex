\chapter{Conclusion}\label{chap:conclusion}

The goal of this thesis was to evaluate the FunArray technique. I reached that goal by implementing a standalone static analyser that employs the principles of abstract interpretation and abstracts arrays via the FunArray. It is able to work with arbitrary abstract domains. The analyser fully-automatically divides arrays into semantic segments and requires no additional manual input for this task.
I evaluated my analyser by testing it against benchmarks from SV-COMP. My analyser was able to determine non-trivial invariants for $61\%$ of the included loops and assert $10\%$ of the proof obligations. The analysis ran in about a millisecond per benchmark, suggesting that this approach can easily be applied onto real world usages without any significant time effort. These results seem to confirm Cousot, Cousot and Logozzo's findings.

\section{Outlook}

To fit the scope of a bachelor thesis, the analyser is fairly limited in its capabilities. It runs on a single abstract domain, that itself is fairly limited in what can be approximated with it. Furthermore it is not able to actually analyse any real program code, as any program first has to be translated into its EDSL and since its support for certain language features is limited. Therefore it might be beneficial to take the implementation of the FunArray and include it into an already existing, more extensive and established analyser, such as CPAchecker for example\footnote{\url{https://cpachecker.sosy-lab.org/}}.
This could be combined with introducing additional more specialised abstract domains to be able to verify certain types of programs. As I previously suggested, an abstraction of the cross product between array index and segment value might be able to verify whether a FunArray segment is sorted.

The FunArray could also greatly improve by working on the restrictions imposed by the required normal form for expressions in array bounds. There are several approaches that could be promising in this matter: The simplest one would be to improve the normalising process. It might be possible to normalise certain expressions that are currently deemed not normalisable. Certain edge cases that are currently not being handled immediately come to mind: For example the expression \texttt{1 * e} could easily be turned into \texttt{e + 0}. This has not been done because finding all such speciality edge case was outside of the scope of this thesis. It can also be hypothesised that there is another better method to determine normal forms. Another approach for dealing with the problems caused by the chosen normal form, would be to simply choose another, less restrictive form than $\texttt{v}+k$. Cousot, Cosuot and Logozzo mentioned a linear expression $a\cdot\texttt{v}+k$ for example \cite{cousot2011}. This would yield the benefit of being able to more easily normalise multiplications. The third approach I suggest to solve the problems caused by the normal form requirement is to simply drop it. The FunArray would then accept arbitrary expressions in its bounds. On first thought it might seem as if this could lead to other problems since a syntactic comparison between bound expressions would become impossible or only possible in certain cases, but that is not the case. If the need for a syntactic comparison for array accesses or assignments arises, the contained expressions could then still be brought into a normal form. It might even be possible to then try multiple different normal forms that supplement each other. Therefore this approach seems to be really promising. The evaluation of these proposed changes is being left to future research.

\section{Closing Thoughts}

To conclude, the FunArray is a scalable and versatile method to abstract arrays. Its precision can be easily fine tuned by employing different abstractions for array elements, variables or bounds. I was able to implement it from scratch and reconfirm Cousot, Cousot and Logozzo's findings concerning its abilities in verifying program code.