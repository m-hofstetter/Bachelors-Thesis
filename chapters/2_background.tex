\chapter{Background}





\section{Properties}

Consider a set of entities $\mathcal{E}$. A formal property $P\subseteq \wp(\mathcal{E}) $ is a set of entities that have this property \cite[chapter 8]{cousot2021}. In the introduction we abstracted the value of a variable, that would be an integer in the concrete, to its sign. With the set of integers as our set of entities $\mathcal{E}=\mathbb{Z}$, a ``positive'' property is defined as $P_{pos}=\{z\in \mathcal{E} \;|\; 0<z\}$ and we can define some more semantic properties like in table \ref{table:properties}.
\begin{table}[hbt]
\begin{center}
  \begin{tabular}{l|l}
  $\mathsf{false}$ & $\emptyset$\\
   $P_{0}$ & $\{0\}$\\
   $P_{pos}$ & $\{z\in \mathbb{Z} \;|\; 0<z\}$\\
   $P_{neg}$ & $\{z\in \mathbb{Z} \;|\; 0>z\}$\\
   $P_{pos0}$ & $\{z\in \mathbb{Z} \;|\; 0\leq z\}$\\
   $P_{neg0}$ & $\{z\in \mathbb{Z} \;|\; 0\geq z\}$\\
   $P_{even}$ & $\{z\in \mathbb{Z} \;|\; \exists k\in\mathbb{Z}:2k=z \}$ \\
   $P_{odd}$ & $\{z\in \mathbb{Z} \;|\; \exists k\in\mathbb{Z}:2k+1=z \}$ \\
   $P_{pos\_even}$ & $\{z\in \mathbb{Z} \;|\; z>0 \wedge \exists k\in\mathbb{Z}:2k=z \} = P_{pos} \cap P_{even}$ \\
   $\vdots$ &$\vdots$\\
   $\mathsf{true}$ & $\mathbb{Z}$\\
  \end{tabular}
  \caption{An incomplete selection of properties for $\mathbb{Z}$.}\label{table:properties}
  \end{center}
\end{table}

We call a property $P$ ``stronger'' than $P'$ (or $P'$ ``weaker'' than $P$) if $P\subseteq P'$. Its set representation contains less elements and we therefore have more information about an element that fulfils said property. The weakest property is the $\mathsf{true}$ property that is satisfied by alle elements and the strongest is $\mathsf{false}$ which is satisfied by none \cite[chapter 8]{cousot2021}. Not all properties from $\wp(\mathcal{E})$ carry a semantic meaning. We therefore only consider the set of properties of interest $C\subseteq\wp(\mathcal{E})$. If we want to analyse the signs of integers this could be $C_{sign}=\{\mathsf{false}, P_{0}, P_{pos}, P_{neg}, P_{pos0}, P_{neg0}, P_{not0}, \mathsf{true}\}$. The poset  $\langle C,\subseteq\rangle$ is called the ``concrete domain''.

\section{Abstraction}

Now consider a set of abstract properties $A$. This is not a power set of concrete values anymore but a set of purely semantic symbols that represent abstract properties. If there exists a Galois connection $\langle C,\subseteq\rangle \galois{\alpha}{\gamma}\langle A\sqsubseteq\rangle$, we call $\langle A\sqsubseteq\rangle$ the abstract domain, $\alpha\in C\to A$ the abstraction function and $\gamma\in A\to C$ the concretisation function \cite[chapter 11]{cousot2021}. To put the working principle of Galois connections into simple terms: $A$'s elements abstract $C$'s elements and $\sqsubseteq$ works analogous in the abstract to $\subseteq$ in the concrete. More formally: $\forall P_C\in C:\forall P_A \in A:\alpha(P_C)\sqsubseteq P_A \Longleftrightarrow P_C \subseteq \gamma(P_A)$.

\input{res/hasse_sign.tex}

\section{A Simple Language}

Consider a simple programming language as defined in figure \ref{fig:bnf_simplelanguage}. In the following sections we will assign it concrete semantics for actually executing a program written in this language in the concrete. We will then compare this concrete semantics to an abstract interpretation of the language.

\input{res/bnf_simplelanguage.tex}

\section{Expression Semantics}

Determining the meaning of a particular statement requires us to know the current state of the program. The expression \texttt{i + 1} has an entirely different result, depending on the value of the variable \texttt{i}, which is recorded in the program's concrete scalar variable environment. An environment is defined as a function $\rho\in\mathcal{R}_v$ with $\mathcal{R}_v \triangleq \mathbb{X}\mapsto\mathcal{V}$, where $\mathbb{X}$ is the set of syntactical variable names and $\mathcal{V}$ is the set of values they can take \cite{cousot2011}.
Now consider the simple syntactical expression $\mathtt{e}\in\mathbb{E}$. It only contains scalar constants, scalar variable references and operators. Now $\llbracket\mathtt{e}\rrbracket\rho$ describes the semantics of \texttt{e} in the concrete variable environment $\rho$. The semantics of a variable \texttt{i} is defined as $\llbracket\mathtt{i}\rrbracket\rho=\rho(\mathtt{i})$ and the semantics of a syntactic operator $\circledast$ is defined as $\llbracket\mathtt{e_0\circledast e_1}\rrbracket\rho=\llbracket\mathtt{e_0}\rrbracket\rho \ast\llbracket\mathtt{e_1}\rrbracket\rho$ \cite{scott1971}. 
Imagine a variable environment $\rho$, where $\rho(\mathtt{i})=1$, for example. Our previously mentioned expression \texttt{i + 1} evaluates to:

\begin{equation*}
\begin{aligned}
\llbracket\mathtt{i \;\texttt{+}\; 1}\rrbracket\rho &=\llbracket\mathtt{i}\rrbracket\rho +\llbracket\mathtt{1}\rrbracket\rho \\
& = \rho(\mathtt{i}) + 1\\
& = 1+1\\
& = 2
\end{aligned}
\end{equation*}
\vspace{1mm}

\noindent When executing programs in the abstract, we cannot rely on integer arithmetics to define our semantics. Instead we will have to define an abstract counterpart $f^\#$ for every concrete operator $f$. An abstract interpretation is consistent with the concrete execution, iff $f(x)\subseteq\gamma(f^\#(\alpha(x)))$, as shown in figure \ref{fig:abstractfunction} \cite{cousot1977}.

\input{res/abstract_function.tex}

\noindent This ensures that the abstract result of an operation includes at least (but not necessarily only) the result that the operation would have in the concrete. Let us take a look at the multiplication operation \texttt{*}. Its concrete semantics $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket\rho$ is trivially defined as $\llbracket\mathtt{e_1}\rrbracket\rho \times\llbracket\mathtt{e_2}\rrbracket\rho$. When we want to interpret this operation in the abstract domain of signs $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket^\pm\rho$, we will now have to come up with a definition of sign multiplication $\times_\pm$. The most trivial of these would be $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket^\pm\rho=\top$, meaning the result is unknown. We can, however, further narrow down a more precise definition as can be seen in table \ref{table:multiply}. This satisfies our condition for an abstract operation, since $\times(x,y)\subseteq\gamma(\times_\pm(\alpha(x),\alpha(y)))$ for all $x,y\in\mathbb{Z}$ and it also makes intuitive sense, as for example a multiplication of two positive integers will result in another positive integer, a multiplication of any integer with zero will result in zero and so on.


\begin{table}[hbt]
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
            $\times_\pm$& $\perp$ & $<0$    & $0$     & $>0$    & $\leq0$ & $\neq0$ & $\geq0$ & $\top$  \\ \hline
            $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ \\
            $<0$    & $\perp$ & $>0$    & $0$     & $<0$    & $\geq0$ & $\neq0$ & $\leq0$ & $\top$  \\
            $0$     & $\perp$ & $0$     & $0$     & $0$     & $0$     & $0$     & $0$     & $0$     \\
            $>0$    & $\perp$ & $<0$    & $0$     & $>0$    & $\leq0$ & $\neq0$ & $\geq0$ & $\top$  \\
            $\leq0$ & $\perp$ & $\geq0$ & $0$     & $\leq0$ & $\geq0$ & $\top$  & $\leq0$ & $\top$  \\
            $\neq0$ & $\perp$ & $\neq0$ & $0$     & $\neq0$ & $\top$  & $\neq0$ & $\top$  & $\top$  \\
            $\geq0$ & $\perp$ & $\leq0$ & $0$     & $\geq0$ & $\leq0$ & $\top$  & $\geq0$ & $\top$  \\
            $\top$  & $\perp$ & $\top$  & $0$     & $\top$  & $\top$  & $\top$  & $\top$  & $\top$ 
        \end{tabular}
  \caption{A table showcasing the result of the abstract property transformer $\times_\pm$ which is an abstraction of the concrete multiplication operator.}\label{table:multiply}
  \end{center}
\end{table}

\section{Transformers}

Our simple language not only contains expressions, but also commands or statements that modify the environment itself. For example, consider the environment $\rho$ where $\rho(\mathtt{i})=1$. After executing the command \texttt{i := i + 1}, the value of the variable \texttt{i} changes and therefore the environment $\rho'$ after the execution of the command is different from $\rho$. We write $\llbracket \texttt{i\;:=\;i\;+\;1} \rrbracket\rho=\rho[\mathtt{i}:=\texttt{i\;+\;1}]=\rho'$, meaning the semantics of the environment $\rho$ after executing an assignment \texttt{i\;:=\;i\;+\;1} is an environment $\rho'$ where all occurrences of \texttt{i} have been replaced by \texttt{i\;+\;1}. 
More generally the semantics of an assignment is defined as $\llbracket \texttt{i\;:=\;e} \rrbracket\rho=\rho[\mathtt{i}:=\texttt{e}]$ with $\rho[\mathtt{i}:=\texttt{e}](\mathtt{i})=\llbracket\mathtt{e}\rrbracket\rho$ \cite{cousot2011}. Commands that alter the environment are called transformations. They are basically functions in $\mathcal{R}_v\mapsto\mathcal{R}_v$ \cite{scott1971}.
The process in an abstract interpretation is the same, with the difference being of course, that expressions are being evaluated in the abstract domain.

\section{The Interval Domain}

Until this point we have been doing our abstract interpretation in the sign domain only. Let us introduce another, more precise one: The interval domain. This domain does not abstract the sign property of a scalar variable, but rather the property of which interval it is included in. An interval $[\underline{x},\overline{x}]$ has the concretisation $\gamma([\underline{x},\overline{x}])=\{z\in\mathbb{Z} \;|\; \underline{x}\leq z \leq \overline{x}\}$. Abstract expression operations follow usual interval arithmetics. For example, $[\underline{x},\overline{x}]+[\underline{y},\overline{y}]=[\underline{x}+\underline{y},\overline{x}+\overline{y}]$. Figure \ref{fig:domaincomparison} compares the sign domain to the interval domain and shows graphically how it abstracts in a more precise manner. Figure \ref{fig:intervaldomain} shows the interval lattice as a Hasse diagram.

\input{res/domaincomparison.tex}

\input{res/hasse_interval.tex}

\section{Fixpoint Analysis}

\section{The FunArray}

\subsection{Abstract Array Segmentation Predicates}

A FunArray predicate takes the form $\{e_1^1\ldots e_{m^1}^1\} \,P_1\, \{e_1^2\ldots e_{m^2}^2\}[?^2]\,P_2\,\ldots\allowbreak\,P_{n-1}\,\allowbreak\{e_1^n\ldots e_{m^n}^n\}[?^n]$ \cite{cousot2011}, where $e_1^i\ldots e_{m^i}^i$


\vspace{0.2cm}
\begin{figure}
\begin{center}
\begin{tikzpicture}

	\draw (0,0) -- (0,0.5);
	\draw (0,0) -- node[above]{$P_1$} (2,0);
	\draw (0,0.5) -- (2,0.5);
	\node[below] at (0,0) {$\{e_1^1\ldots e_{m^1}^1\}$};
	
	\draw (2,0) -- (2,0.5);
	\draw (2,0) -- node[above, xshift=0.5cm]{$P_2$} (3,0);
	\draw (2,0.5) -- (3,0.5);
	\node[below] at (2,0) {$\{e_1^2\ldots e_{m^2}^2\}$};
	\draw[dashed] (3,0) -- (4,0);
	\draw[dashed] (3,0.5) -- (4,0.5);
	
	
	\draw[dashed] (5,0) -- (5.5,0);
	\draw[dashed] (5,0.5) -- (5.5,0.5);
	\draw (5.5,0) -- (5.5,0.5);
	\draw (7.5,0) -- (7.5,0.5);
	\draw (5.5,0) -- node[above]{$P_{n-1}$} (7.5,0);
	\draw (5.5,0.5) -- (7.5,0.5);
	
	\node[below] at (7.5,0) {$\{e_1^n\ldots e_{m^n}^n\}$};
	
	
	
%	\draw (0,0) -- (4,0);
%    \draw (0,0.5) -- (4,0.5);
%
%    \draw (0,0) -- (0,0.5);
%    \draw (0,-0.25) node {\texttt{\string{0\string}}};
%
%    \draw (1,-0.05) node[anchor=south] {$[0,0]$};
%
%    \draw (2,0) -- (2,0.5);
%    \draw (2,-0.25) node {\texttt{\string{i\string}}};
%    
%    \draw (3,0) node[anchor=south] {$\top$};
%    
%    \draw (4,0) -- (4,0.5);
%    \draw (4,-0.25) node {\texttt{\string{n\string}}};
\end{tikzpicture}
\end{center}
\caption{Graphical representation of a FunArray $\{e_1^1\ldots e_{m^1}^1\} \,P_1\,\allowbreak \{e_1^2\ldots\allowbreak e_{m^2}^2\}[?^2]\allowbreak\,P_2\,\ldots\,P_{n-1}\,\{e_1^n\ldots e_{m^n}^n\}[?^n]$.}
\end{figure}











