\chapter{Background}





\section{Properties}

Consider a set of entities $\mathcal{E}$. A formal property $P\subseteq \wp(\mathcal{E}) $ is a set of entities that have this property \cite[chapter 8]{cousot2021}. In the introduction we abstracted the value of a variable, that would be an integer in the concrete, to its sign. With the set of integers as our set of entities $\mathcal{E}=\mathbb{Z}$, a ``positive'' property is defined as $P_{pos}=\{z\in \mathcal{E} \;|\; 0<z\}$ and we can define some more semantic properties like in table \ref{table:properties}.
\begin{table}[hbt]
\begin{center}
  \begin{tabular}{l|l}
  $\mathsf{false}$ & $\emptyset$\\
   $P_{0}$ & $\{0\}$\\
   $P_{pos}$ & $\{z\in \mathbb{Z} \;|\; 0<z\}$\\
   $P_{neg}$ & $\{z\in \mathbb{Z} \;|\; 0>z\}$\\
   $P_{pos0}$ & $\{z\in \mathbb{Z} \;|\; 0\leq z\}$\\
   $P_{neg0}$ & $\{z\in \mathbb{Z} \;|\; 0\geq z\}$\\
   $P_{even}$ & $\{z\in \mathbb{Z} \;|\; \exists k\in\mathbb{Z}:2k=z \}$ \\
   $P_{odd}$ & $\{z\in \mathbb{Z} \;|\; \exists k\in\mathbb{Z}:2k+1=z \}$ \\
   $P_{pos\_even}$ & $\{z\in \mathbb{Z} \;|\; z>0 \wedge \exists k\in\mathbb{Z}:2k=z \} = P_{pos} \cap P_{even}$ \\
   $\vdots$ &$\vdots$\\
   $\mathsf{true}$ & $\mathbb{Z}$\\
  \end{tabular}
  \caption{An incomplete selection of properties for $\mathbb{Z}$.}\label{table:properties}
  \end{center}
\end{table}

We call a property $P$ ``stronger'' than $P'$ (or $P'$ ``weaker'' than $P$) if $P\subseteq P'$. Its set representation contains less elements and we therefore have more information about an element that fulfils said property. The weakest property is the $\mathsf{true}$ property that is satisfied by alle elements and the strongest is $\mathsf{false}$ which is satisfied by none \cite[chapter 8]{cousot2021}. Not all properties from $\wp(\mathcal{E})$ carry a semantic meaning. We therefore only consider the set of properties of interest $C\subseteq\wp(\mathcal{E})$. If we want to analyse the signs of integers this could be $C_{sign}=\{\mathsf{false}, P_{0}, P_{pos}, P_{neg}, P_{pos0}, P_{neg0}, P_{not0}, \mathsf{true}\}$. The poset  $\langle C,\subseteq\rangle$ is called the ``concrete domain''.

\section{Abstraction}

Now consider a set of abstract properties $A$. This is not a power set of concrete values anymore but a set of purely semantic symbols that represent abstract properties. If there exists a Galois connection $\langle C,\subseteq\rangle \galois{\alpha}{\gamma}\langle A\sqsubseteq\rangle$, we call $\langle A\sqsubseteq\rangle$ the abstract domain, $\alpha\in C\to A$ the abstraction function and $\gamma\in A\to C$ the concretisation function \cite[chapter 11]{cousot2021}. To put the working principle of Galois connections into simple terms: $A$'s elements abstract $C$'s elements and $\sqsubseteq$ works analogous in the abstract to $\subseteq$ in the concrete. More formally: $\forall P_C\in C:\forall P_A \in A:\alpha(P_C)\sqsubseteq P_A \Longleftrightarrow P_C \subseteq \gamma(P_A)$.

\input{res/hasse_sign.tex}

\section{A Simple Language}

Consider a simple programming language as defined in figure \ref{fig:bnf_simplelanguage}. In the following sections we will assign it concrete semantics for actually executing a program written in this language in the concrete. We will then compare this concrete semantics to an abstract interpretation of the language.

\input{res/bnf_simplelanguage.tex}

\section{Expression Semantics}

Determining the meaning of a particular statement requires us to know the current state of the program. The expression \texttt{i + 1} has an entirely different result, depending on the value of the variable \texttt{i}, which is recorded in the program's concrete scalar variable environment. An environment is defined as a function $\rho\in\mathcal{R}_v$ with $\mathcal{R}_v \triangleq \mathbb{X}\mapsto\mathcal{V}$, where $\mathbb{X}$ is the set of syntactical variable names and $\mathcal{V}$ is the set of values they can take \cite{cousot2011}.
Now consider the simple syntactical expression $\mathtt{e}\in\mathbb{E}$. It only contains scalar constants, scalar variable references and operators. Now $\llbracket\mathtt{e}\rrbracket\rho$ describes the semantics of \texttt{e} in the concrete variable environment $\rho$. The semantics of a variable \texttt{i} is defined as $\llbracket\mathtt{i}\rrbracket\rho=\rho(\mathtt{i})$ and the semantics of a syntactic operator $\circledast$ is defined as $\llbracket\mathtt{e_0\circledast e_1}\rrbracket\rho=\llbracket\mathtt{e_0}\rrbracket\rho \ast\llbracket\mathtt{e_1}\rrbracket\rho$ \cite{scott1971}. 
Imagine a variable environment $\rho$, where $\rho(\mathtt{i})=1$, for example. Our previously mentioned expression \texttt{i + 1} evaluates to:

\begin{equation*}
\begin{aligned}
\llbracket\mathtt{i \;\texttt{+}\; 1}\rrbracket\rho &=\llbracket\mathtt{i}\rrbracket\rho +\llbracket\mathtt{1}\rrbracket\rho \\
& = \rho(\mathtt{i}) + 1\\
& = 1+1\\
& = 2
\end{aligned}
\end{equation*}
\vspace{1mm}

\noindent When executing programs in the abstract, we cannot rely on integer arithmetics to define our semantics. Instead we will have to define an abstract counterpart $f^\#$ for every concrete operator $f$. An abstract interpretation is consistent with the concrete execution, iff $f(x)\subseteq\gamma(f^\#(\alpha(x)))$, as shown in figure \ref{fig:abstractfunction} \cite{cousot1977}.

\input{res/abstract_function.tex}

\noindent This ensures that the abstract result of an operation includes at least (but not necessarily only) the result that the operation would have in the concrete. Let us take a look at the multiplication operation \texttt{*}. Its concrete semantics $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket\rho$ is trivially defined as $\llbracket\mathtt{e_1}\rrbracket\rho \times\llbracket\mathtt{e_2}\rrbracket\rho$. When we want to interpret this operation in the abstract domain of signs $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket^\pm\rho$, we will now have to come up with a definition of sign multiplication $\times_\pm$. The most trivial of these would be $\llbracket\mathtt{e_1\texttt{ * } e_2}\rrbracket^\pm\rho=\top$, meaning the result is unknown. We can, however, further narrow down a more precise definition as can be seen in table \ref{table:multiply}. This satisfies our condition for an abstract operation, since $\times(x,y)\subseteq\gamma(\times_\pm(\alpha(x),\alpha(y)))$ for all $x,y\in\mathbb{Z}$ and it also makes intuitive sense, as for example a multiplication of two positive integers will result in another positive integer, a multiplication of any integer with zero will result in zero and so on.


\begin{table}[hbt]
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
            $\times_\pm$& $\perp$ & $<0$    & $0$     & $>0$    & $\leq0$ & $\neq0$ & $\geq0$ & $\top$  \\ \hline
            $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ & $\perp$ \\
            $<0$    & $\perp$ & $>0$    & $0$     & $<0$    & $\geq0$ & $\neq0$ & $\leq0$ & $\top$  \\
            $0$     & $\perp$ & $0$     & $0$     & $0$     & $0$     & $0$     & $0$     & $0$     \\
            $>0$    & $\perp$ & $<0$    & $0$     & $>0$    & $\leq0$ & $\neq0$ & $\geq0$ & $\top$  \\
            $\leq0$ & $\perp$ & $\geq0$ & $0$     & $\leq0$ & $\geq0$ & $\top$  & $\leq0$ & $\top$  \\
            $\neq0$ & $\perp$ & $\neq0$ & $0$     & $\neq0$ & $\top$  & $\neq0$ & $\top$  & $\top$  \\
            $\geq0$ & $\perp$ & $\leq0$ & $0$     & $\geq0$ & $\leq0$ & $\top$  & $\geq0$ & $\top$  \\
            $\top$  & $\perp$ & $\top$  & $0$     & $\top$  & $\top$  & $\top$  & $\top$  & $\top$ 
        \end{tabular}
  \caption{A table showcasing the result of the abstract property transformer $\times_\pm$ which is an abstraction of the concrete multiplication operator.}\label{table:multiply}
  \end{center}
\end{table}

\section{Transformers}

Our simple language not only contains expressions, but also commands or statements that modify the environment itself. For example, consider the environment $\rho$ where $\rho(\mathtt{i})=1$. After executing the command \texttt{i := i + 1}, the value of the variable \texttt{i} changes and therefore the environment $\rho'$ after the execution of the command is different from $\rho$. We write $\llbracket \texttt{i\;:=\;i\;+\;1} \rrbracket\rho=\rho[\mathtt{i}:=\texttt{i\;+\;1}]=\rho'$, meaning the semantics of the environment $\rho$ after executing an assignment \texttt{i\;:=\;i\;+\;1} is an environment $\rho'$ where all occurrences of \texttt{i} have been replaced by \texttt{i\;+\;1}. 
More generally the semantics of an assignment is defined as $\llbracket \texttt{i\;:=\;e} \rrbracket\rho=\rho[\mathtt{i}:=\texttt{e}]$ with $\rho[\mathtt{i}:=\texttt{e}](\mathtt{i})=\llbracket\mathtt{e}\rrbracket\rho$ \cite{cousot2011}. Commands that alter the environment are called transformations. They are basically functions in $\mathcal{R}_v\mapsto\mathcal{R}_v$ \cite{scott1971}.
The process in an abstract interpretation is the same, with the difference being of course, that expressions are being evaluated in the abstract domain.

\section{The Interval Domain}

Until this point we have been doing our abstract interpretation in the sign domain only. Let us introduce another, more precise one: The interval domain. This domain does not abstract the sign property of a scalar variable, but rather the property of which interval it is included in. An interval $[\underline{x},\overline{x}]$ has the concretisation $\gamma([\underline{x},\overline{x}])=\{z\in\mathbb{Z} \;|\; \underline{x}\leq z \leq \overline{x}\}$.


\begin{figure}[!htb]
\begin{center}
\begin{tikzpicture}
 		\coordinate (A) at (0,-2);
		\coordinate (B) at (0,2);
		\coordinate (C) at (-2,0);
		\coordinate (D) at (2,0);
		
		\draw [draw=none, fill=gray, fill opacity=0.2] (0,0) -- (0,2) -- (2,2) -- (2,0) -- cycle;
		
		%Axis
		\draw[<->] (A) -- (B) node [above] {$x$};
		\draw[<->] (C) -- (D) node [right] {$y$};
		
		
		\filldraw[black] (0.5,0.8) circle (1pt);	
		\filldraw[black] (1,1.2) circle (1pt);
		\filldraw[black] (1.5,1.4) circle (1pt);	
		\filldraw[black] (0.8,1.8) circle (1pt);
		\filldraw[black] (0.7,0.5) circle (1pt);	
		\filldraw[black] (1.3,0.7) circle (1pt);	
		
		
		\node at (0,2.8) {Sign Domain};
		
		\coordinate (E) at (5,-2);
		\coordinate (F) at (5,2);
		\coordinate (G) at (3,0);
		\coordinate (H) at (7,0);
		
		\draw [draw=none, fill=gray, fill opacity=0.2] (5.5,0.5) -- (5.5,1.8) -- (6.5,1.8) -- (6.5,0.5) -- cycle;
		
		\draw[-] (5.5,0.1) -- (5.5,-0.1);
		\draw[-] (6.5,0.1) -- (6.5,-0.1);
		
		\draw[-] (4.9,1.8) -- (5.1,1.8);
		\draw[-] (4.9,0.5) -- (5.1,0.5);
		
		\node at (5,1.8)[left, xshift=-1mm] {$\overline{x}$};
		\node at (5,0.5)[left, xshift=-1mm] {$\underline{x}$};
		
		\node at (5.5,0)[below, yshift=-1mm] {$\underline{y}$};
		\node at (6.5,0)[below, yshift=-1mm] {$\overline{y}$};
		
		%Axis
		\draw[<->] (E) -- (F) node [above] {$x$};
		\draw[<->] (G) -- (H) node [right] {$y$};
		
		\filldraw[black] (5.5,0.8) circle (1pt);	
		\filldraw[black] (6,1.2) circle (1pt);
		\filldraw[black] (6.5,1.4) circle (1pt);	
		\filldraw[black] (5.8,1.8) circle (1pt);
		\filldraw[black] (5.7,0.5) circle (1pt);	
		\filldraw[black] (6.3,0.7) circle (1pt);		
		
		\node at (5,2.8) {Interval Domain};		
		
		
\end{tikzpicture}
\end{center}
\caption{A diagram comparing abstract representation for a set of states. In this example a concrete state consists only of two scalar variable values $x$ and $y$. Therefore a concrete state can be represented as a point in the plane. The sign domain state abstracting the marked concrete states spans an entire quadrant of the coordinate system, whereas the interval domain state only occupies the rectangle encasing the states.}\label{fig:domaincomparison}
\end{figure}

\input{res/hasse_interval.tex}

\section{Fixpoint Analysis}

\section{The FunArray}

\subsection{Abstract Array Segmentation Predicates}


